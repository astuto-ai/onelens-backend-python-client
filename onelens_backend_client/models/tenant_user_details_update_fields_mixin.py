# coding: utf-8

"""
onelens-backend

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

The version of the OpenAPI document: 1.0.0.1
Generated by OpenAPI Generator (https://openapi-generator.tech)

Do not edit the class manually.
"""  # noqa: E501

from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from onelens_backend_client.models.user_persona import UserPersona
from typing import Set
from typing_extensions import Self


class TenantUserDetailsUpdateFieldsMixin(BaseModel):
    """
    TenantUserDetailsUpdateFieldsMixin
    """  # noqa: E501

    first_name: Optional[StrictStr] = None
    middle_name: Optional[StrictStr] = None
    last_name: Optional[StrictStr] = None
    mobile_country_code: Optional[StrictStr] = None
    mobile_number: Optional[StrictStr] = None
    persona: Optional[UserPersona] = None
    job_title: Optional[StrictStr] = None
    manager: Optional[StrictStr] = None
    city: Optional[StrictStr] = None
    state: Optional[StrictStr] = None
    country: Optional[StrictStr] = None
    display_language: Optional[StrictStr] = None
    preferred_currency: Optional[StrictStr] = None
    timezone: Optional[StrictStr] = None
    display_date_format: Optional[StrictStr] = None
    display_time_format: Optional[StrictStr] = None
    __properties: ClassVar[List[str]] = [
        "first_name",
        "middle_name",
        "last_name",
        "mobile_country_code",
        "mobile_number",
        "persona",
        "job_title",
        "manager",
        "city",
        "state",
        "country",
        "display_language",
        "preferred_currency",
        "timezone",
        "display_date_format",
        "display_time_format",
    ]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )

    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of TenantUserDetailsUpdateFieldsMixin from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # set to None if first_name (nullable) is None
        # and model_fields_set contains the field
        if self.first_name is None and "first_name" in self.model_fields_set:
            _dict["first_name"] = None

        # set to None if middle_name (nullable) is None
        # and model_fields_set contains the field
        if self.middle_name is None and "middle_name" in self.model_fields_set:
            _dict["middle_name"] = None

        # set to None if last_name (nullable) is None
        # and model_fields_set contains the field
        if self.last_name is None and "last_name" in self.model_fields_set:
            _dict["last_name"] = None

        # set to None if mobile_country_code (nullable) is None
        # and model_fields_set contains the field
        if (
            self.mobile_country_code is None
            and "mobile_country_code" in self.model_fields_set
        ):
            _dict["mobile_country_code"] = None

        # set to None if mobile_number (nullable) is None
        # and model_fields_set contains the field
        if self.mobile_number is None and "mobile_number" in self.model_fields_set:
            _dict["mobile_number"] = None

        # set to None if persona (nullable) is None
        # and model_fields_set contains the field
        if self.persona is None and "persona" in self.model_fields_set:
            _dict["persona"] = None

        # set to None if job_title (nullable) is None
        # and model_fields_set contains the field
        if self.job_title is None and "job_title" in self.model_fields_set:
            _dict["job_title"] = None

        # set to None if manager (nullable) is None
        # and model_fields_set contains the field
        if self.manager is None and "manager" in self.model_fields_set:
            _dict["manager"] = None

        # set to None if city (nullable) is None
        # and model_fields_set contains the field
        if self.city is None and "city" in self.model_fields_set:
            _dict["city"] = None

        # set to None if state (nullable) is None
        # and model_fields_set contains the field
        if self.state is None and "state" in self.model_fields_set:
            _dict["state"] = None

        # set to None if country (nullable) is None
        # and model_fields_set contains the field
        if self.country is None and "country" in self.model_fields_set:
            _dict["country"] = None

        # set to None if display_language (nullable) is None
        # and model_fields_set contains the field
        if (
            self.display_language is None
            and "display_language" in self.model_fields_set
        ):
            _dict["display_language"] = None

        # set to None if preferred_currency (nullable) is None
        # and model_fields_set contains the field
        if (
            self.preferred_currency is None
            and "preferred_currency" in self.model_fields_set
        ):
            _dict["preferred_currency"] = None

        # set to None if timezone (nullable) is None
        # and model_fields_set contains the field
        if self.timezone is None and "timezone" in self.model_fields_set:
            _dict["timezone"] = None

        # set to None if display_date_format (nullable) is None
        # and model_fields_set contains the field
        if (
            self.display_date_format is None
            and "display_date_format" in self.model_fields_set
        ):
            _dict["display_date_format"] = None

        # set to None if display_time_format (nullable) is None
        # and model_fields_set contains the field
        if (
            self.display_time_format is None
            and "display_time_format" in self.model_fields_set
        ):
            _dict["display_time_format"] = None

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of TenantUserDetailsUpdateFieldsMixin from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate(
            {
                "first_name": obj.get("first_name"),
                "middle_name": obj.get("middle_name"),
                "last_name": obj.get("last_name"),
                "mobile_country_code": obj.get("mobile_country_code"),
                "mobile_number": obj.get("mobile_number"),
                "persona": obj.get("persona"),
                "job_title": obj.get("job_title"),
                "manager": obj.get("manager"),
                "city": obj.get("city"),
                "state": obj.get("state"),
                "country": obj.get("country"),
                "display_language": obj.get("display_language"),
                "preferred_currency": obj.get("preferred_currency"),
                "timezone": obj.get("timezone"),
                "display_date_format": obj.get("display_date_format"),
                "display_time_format": obj.get("display_time_format"),
            }
        )
        return _obj
